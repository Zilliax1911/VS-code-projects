# 面经总结

## 1.语言基础

### （0）指针和引用的区别

### （13）C++中static用法和意义

static的意思是静态的，可以用来修饰变量，函数和类成员。

```C++
//变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里
#include <iostream>
using namespace std;

void func() {
	static int a = 0;
	// int a = 0;
	a++;
	cout << a ;
}

int main()
{
	for (int i = 0; i < 5; ++i) {
		func();
	}
	cout<<endl;

	return 0;
}
//12345
```

- 函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。

- 类成员：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。

【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。

注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。





**构造函数不能为虚函数，而析构函数可以且常常是虚函数**

- 虚函数的调用需要虚函数表（vptr）指针，而这个指针存放在对象的内存空间中，在构造函数中进行初始化操作，让他指向正确的虚函数表。所以需要调用构造函数来创建和初始化指针的值，但是构造函数的调用是在成员对象分配空间过后的，所以构造函数不能为虚函数。
- 虚函数是基于对象的，而构造函数是用来产生对象的

**虚函数的作用**：

- 实现多态

**多态就是将接口与实现进行分离**

- 基类指针指向子类对象

**具有构造函数的类对象被创建时，编译系统为该对象分配内存空间，并自动调用该构造函数，由构造函数完成数据成员的初始化工作。**

- 构造函数的调用在成员对象分配空间之后

**析构函数在对象消亡时即自动被调用，通常用在释放内存**



**构造函数和析构函数调用的顺序**

- 构造函数的调用顺序
  - 基类构造函数、对象成员构造函数、派生类本身的构造函数
- 析构函数的调用顺序
  - 派生类、对象成员、基类



**说说你理解的四种智能指针**

- 为什么要使用智能指针？
  - 智能指针用来管理指针，避免造成内存泄漏
  - 智能指针就是一个类，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源
- **常用接口**

>T* get();	用来获取auto_ptr封装在内部的指针，获取原始指针
>
>operator()表示操作符重载
>
>release()将内部指针重置为nullptr，但不会改变指针所指向的内容，函数返回指针重置前的值
>
>reset()直接释放内部指针所指向的内存，如果指定了ptr的值，则将其初始化为该值



**unique_ptr**

保证了同一时间只有一个智能指针可以指向对象，它对避免资源泄露很有用，实际就是禁止使用赋值语句对它赋值

**shared_ptr**

共享型，强引用

多个智能指针可以指向同一个对象，使用计数机制来表明对象被多少个指针共享

use_count()来查看个数

shared_ptr.release()释放资源所有权，计数减一，直到计数为0时，资源会被释放

除了可以new构造，还可以通过传入atuo_ptr，weak_ptr，unique_ptr来构造

**weak_ptr**

弱引用，不会增加计数

不是直接指向对象，而是指向其他shared_ptr，通过shared_ptr来进行对象管理

只可以从shared_ptr或者另一个weak_ptr对象构造

用来解决shared_ptr的死锁（相互循环引用）问题，当两个shared_ptr相互引用，那么计数不可能变为0，这时将其中一个赋值给weak_ptr



sizeof(struct)计算结构体大小

- 结构体的大小是 = 结构中最后一个变量的偏移量+变量大小
- 变量的大小 = 上一个变量的偏移量 + 大小

```C++
struct stru{
    char a;	//第一个成员的偏移量为0
    int b;	//第二个成员的偏移量 = (0 + 1) = 1；又必须是sizeof(int) = 4的整数倍;所以=4
    float c;	//第三个成员的偏移量 = (4 + 4) = 8; 又必须是4的整数倍 = 8
    double d;	// 8 + 4 = 12 && 16的整数倍 = 16
}	//结构体的大小  16 + 8 = 24 && 必须是1，4，4，8的整数倍	= 24;
```





### 左值引用和右值引用的区别，右值引用的意义

- RAII，通过值语义控制对象的生命周期

#### 左值和右值的区别

- 右值只能在等号的右边，左值两边皆可
- 右值是纯字面值，将亡值。通过把将亡值赋给其他变量进行转移 （i++是右值，++i是左值

#### 两个引用的区别

- 右值引用能丰富值语义，通过右值引用（移动语义）延长生命周期
- const左值引用能指向右值
- std::move()右值引用可以指向左值
- 声明出的左值引用或右值引用都是左值右值引用的体现

- stl应用
- 智能指针

#### 		emplace_back()和push_back()区别

- em可以直接使用类的构造函数，在对象内部直接构造，性能比移动语义高
- push（）传进去的对象，em（）传进去的构造函数的参数
- push（）会有拷贝以及移动构造函数



### 移动语义

```C++
class A {
public:
    A() {
        p = new int(10);
        cout << "A():P=" << P << endl;
    }
    A(const A& a) {	//深拷贝和浅拷贝
    	p = new int{10};
        memcpy(p, a.p, 10*sizeof(int));
    }
    ~A() {
        if (p != nullptr) {
            delete []p;
            p = nullptr;
        }
    }
    //移动构造函数
    A(A&& A) {
        this->p = a.p;
        a.p = nullptr;
    }
    int *p;
};

int main() {
    //拷贝构造
    A a;
   // move()将左值a变为将亡值
    A b(std::move(a));	//触发移动构造函数
}
```

### 



#### 完美转发

函数模板可以将自己的参数完美地转发到内部调用的其他函数

```C++
void func(int &n) {
    cout << "lvalue=" << endl;
}

void func(int &&n) {
    cou << "rvalue=" << endl;
}

template<typename T>
void revoke(T &&t) {	//万能引用
    func(std::forward<T>(t));	//forward()可以探测出t是左值还是右值
}

int main() {
    int i = 10;
    //左值引用或右值引用创建的对象都是左值
    int &m = i;
    int &&n = 100;
    //static_cast：左值引用变左值，右值引用变右值
    revoke(static_cast<int &>(m));
    revoke(static_cast<int &&>(n));
}
```





### malloc是如何分配内存的，free怎么知道该释放多少内存

- 首先，malloc会从一个内存池中寻找一块足够大的空闲内存块，并将其标记为已使用状态。
- 如果内存池中没有足够大的空闲内存块，则malloc会向操作系统发起系统调用，请求一段连续的内存空间。操作系统会在虚拟内存中为程序分配一段连续的物理内存，并返回其起始地址。
- malloc将返回的内存地址返回给程序，并将其标记为已使用状态。 需要注意的是，由于内存分配是在运行时进行的，因此在使用完毕后需要及时释放内存，避免内存泄漏和浪费。释放内存的方法是使用free函数，将已分配的内存块标记为未使用状态，以便后续程序可以再次使用。 此外，malloc分配的内存块大小可能会略大于程序要求的大小，这是因为malloc会在内存块的头部和尾部分别添加一些额外的信息，用于管理和检测内存的使用情况。这些额外的信息通常包括内存块的大小、是否已使用等信息。这种做法可以帮助程序检测内存泄漏和内存溢出等问题。

- free函数会读取ptr指向的内存块的头部信息，这些信息中包含内存块的使用情况，内存块的大小，然后将整个内存块标记为未使用状态，并将其放回内存池中



### 不使用临时变量实现swap函数

- 加减

```C++
void swap(int& a, int& b) {
    a -= b;
    b += a;
    a = -(a - b);
}
```

- 异或

```C++
void swap(int& a, int& b) {
    a = a^b;
    b = a^b;
    a = a^b;
}
```



### 反转链表

```C++
ListNode* reserve(ListNode* root) {
    ListNode* pre = nullptr;
    ListNode* nxt, cur = root;
    while (cur != nullptr) {
        nxt = cur->next;
        cur->next = pre;
        pre = cur;
        cur = nxt;
    }
    return pre;
}
```



#### Linux和Windows线程有何区别

- linux中线程可以看作是轻量级的进程，抢占式，资源消耗少
- windows中就是基本的线程，协作式，资源消耗相对高



### 2. 计网相关

#### 建立TCP服务器的各个系统调用

建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。 详见：https://blog.csdn.net/qq_37964547/article/details/81429627

#### 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？

> socket() 创建套接字
> bind() 绑定本机端口
> connect() 建立连接 （TCP三次握手在调用这个函数时进行） listen() 监听端口 accept() 接受连接 recv(), read(), recvfrom() 数据接收 send(), write(), sendto() 数据发送 close(), shutdown() 关闭套接字

==使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接==

详见：https://blog.csdn.net/junjun150013652/article/details/37994907

TCP连接与断开详解： https://www.cnblogs.com/felixzh/p/8359066.html

#### 对路由协议的了解

- RIP
- OSPF

#### UDP如何实现可靠传输

因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。

就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。 ———————————————— 原文链接：https://blog.csdn.net/neverever01/article/details/108237531

#### TCP和UDP的区别

- TCP是面向连接的协议，提供的是可靠传输，在收发数据前要通过三次握手来建立连接，使用ACK来对是否收到数据进行验证，而UDP是无连接的协议，不管对方是否收到，收到的是否正确。
- TCP采用拥塞避免和流量控制算法，UDP没有
- TCP对系统资源的要求高，所以速度比UDP慢
- TCP包没有边界，会发生沾包问题，所以采用分包和拆包

#### ping原理

- **Ping**命令会构建一个固定格式的ICMP请求数据包，然后由ICMP协议将这个数据包连同地址一起交给**IP层协议**，IP协议将目的地址和本机地址构建一个IP数据包，并在一个==映射表==中查找出目的地址对应的**MAC地址**，一起交给数据链路层，后者构建一个数据帧，目的地址是IP层传过来的物理地址，源地址则是本机的物理地址，还要附加上一些控制信息，将他们传送出去

- 映射表由

  ARP

  实现，是一种地址解析协议，将IP地址转换为物理地址。

  - 首先分析IP地址确定目的主机和自己是否在同一网段，如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包。

#### TCP（UDP，IP）等首部的认识（http请求报文构成）

https://blog.csdn.net/zhangliangzi/article/details/52554439

#### ==在浏览器中输入URL后执行的全部过程==

- 首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；
- 建立TCP连接，客户端与服务器三次握手；
- 接着是HTTP连接，客户端向服务器发送http连接请求；（http无需额外的连接）
- 服务器对请求进行处理，并返回响应
- 客户端收到http响应，进行数据解析
  - 首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它有dom元素和属性节点组成；
  - 

#### TCP拥塞控制

[![拥塞控制](https://camo.githubusercontent.com/3a1a5b5fa2c63ea33bbd20fe0a3d1544b8bd7d5092ef22a69cbe1154b20a1d76/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939716157467564485672645331736158646c626d4a706269357663334d745932347463326868626d646f59576b75595778706558567559334d75593239744c7956464f535535524356424d6956464e79564351695534526956464e5355354d4355344f4356464f535535516955344e69386c5254596c4f45496c5154556c5254556c5154456c4f55556c5254596c4f45556c5154636c5254556c4f44676c516a59756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)](https://camo.githubusercontent.com/3a1a5b5fa2c63ea33bbd20fe0a3d1544b8bd7d5092ef22a69cbe1154b20a1d76/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939716157467564485672645331736158646c626d4a706269357663334d745932347463326868626d646f59576b75595778706558567559334d75593239744c7956464f535535524356424d6956464e79564351695534526956464e5355354d4355344f4356464f535535516955344e69386c5254596c4f45496c5154556c5254556c5154456c4f55556c5254596c4f45556c5154636c5254556c4f44676c516a59756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)

- 防止过多的数据注入到网络中，发送方维持一个拥塞窗口cwnd的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且在动态地变化。
- 慢启动：主机先以比较小的拥塞窗口进行发送，然后每次翻倍。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候，停止时慢开始，转为拥塞避免算法
- 拥塞避免：让cwnd缓慢地增大，每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。
- 快速重传：当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值变为cwnd值的一半，cwnd变为ssth+3，然后+1+1
- 快速回复：当超过设定的时间没有收到ack时，表示网络拥塞，慢启动阈值ssth变为原来的一半，cwnd = 1，进入慢启动阶段

#### http协议与TCP的区别与联系

联系：HTTP是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。HTTP会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，HTTP会立即将TCP连接断开，这个过程很短。

区别：HTTP是应用层协议，定义的是数据的内容的规范，TCP是传输层的协议，定义的是数据传输和连接的规范。

#### HTTP和HTTPS的区别，由Http升级为HTTPS需要哪些操作

- http是超文本传输协议，信息是明文传输，https则是具有安全性的**SSL**加密传输协议
- http端口是80，https端口是443
- http连接简单，是无状态的；https协议是由SSL+HTTP协议构建的可加密传输，身份认证的网络协议
- https需要CA证书

#### https的具体实现，怎么确保安全性

通过非对称加密的RSA算法和对称加密的传输过程确定

- SSL是传输层的协议
- 客户端浏览器使用https的URL访问web服务器，要求与服务器建立SSL连接
- 服务器将网站的数字证书中的公钥发送一份给浏览器，私钥自己保存
- 浏览器生成加密使用的密钥（**三个随机数**（1.第一次请求服务器时附带的随机数，2.服务器返回时的随机数，3.客户端浏览器收到返回时的随机数）的哈希）
- 浏览器用公钥将密钥加密，发送给服务器
- 服务器用自己的私钥解密出会话密钥，利用会话密钥来加密与客户端之间的通信

#### 单条记录高并发访问的优化

- 服务器端：
  - 使用缓存，如redis等
  - 使用分布式架构进行处理
  - 将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回
  - 将静态资源尽可能在客户端进行缓存
  - 采用ngnix进行负载均衡（Engine X）
- 数据库端：
  - 采用主从复制，读写分离措施
  - 建立适当的索引
  - 分库分表

#### DNS的工作过程和原理

[![img](https://camo.githubusercontent.com/1f46b4d9410593b8fa24d71e786561f47601eccd41ed26f24ae323a64ca843df/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939716157467564485672645331736158646c626d4a706269357663334d745932347463326868626d646f59576b75595778706558567559334d75593239744c7956464f535535524356424d6956464e79564351695534526956464e5355354d4355344f4356464f535535516955344e693945546c4d6c5254596c4f55596c5154556c5254676c5155596c5154496c5254556c4f55496c516b556c5254676c5154636c51544d756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)](https://camo.githubusercontent.com/1f46b4d9410593b8fa24d71e786561f47601eccd41ed26f24ae323a64ca843df/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939716157467564485672645331736158646c626d4a706269357663334d745932347463326868626d646f59576b75595778706558567559334d75593239744c7956464f535535524356424d6956464e79564351695534526956464e5355354d4355344f4356464f535535516955344e693945546c4d6c5254596c4f55596c5154556c5254676c5155596c5154496c5254556c4f55496c516b556c5254676c5154636c51544d756347356e3f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67)

DNS解析有两种方式：递归查询和迭代查询

- 递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。
- 迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果
